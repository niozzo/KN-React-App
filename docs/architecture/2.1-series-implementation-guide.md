# 2.1 Series Implementation Guide

**Version:** 1.0  
**Last Updated:** 2025-01-20  
**Status:** ACTIVE  
**Related Stories:** 2.1f1, 2.1f2, 2.1f3, 2.1f4

## Overview

This guide provides comprehensive implementation details for the 2.1 series stories, focusing on the unified cache management and state management architecture. It serves as a reference for developers working with the new architecture and provides troubleshooting guidance.

## Architecture Components

### 1. Unified Cache Service

The `UnifiedCacheService` serves as the single source of truth for all cache operations in the application.

#### Key Features
- Centralized cache operations (get, set, remove, invalidate, clear)
- Integration with existing cache versioning, monitoring, and consistency services
- Comprehensive error handling and recovery patterns
- Cache health status monitoring
- Performance optimization for large datasets

#### Usage Examples

```typescript
import { unifiedCacheService } from './services/unifiedCacheService';

// Basic cache operations
await unifiedCacheService.set('key', data);
const data = await unifiedCacheService.get('key');
await unifiedCacheService.remove('key');

// Cache invalidation
await unifiedCacheService.invalidate('pattern*');

// Health monitoring
const health = await unifiedCacheService.getHealthStatus();
```

#### Integration Pattern

```typescript
// In service classes
export class MyService {
  constructor(private unifiedCache = unifiedCacheService) {}

  async getData() {
    try {
      const cached = await this.unifiedCache.get('my-data-key');
      if (cached) {
        return cached.data || cached;
      }
      
      // Fetch from API
      const data = await this.fetchFromAPI();
      await this.unifiedCache.set('my-data-key', data);
      return data;
    } catch (error) {
      ErrorHandlingService.handleCacheError(error, {
        component: 'MyService',
        action: 'getData'
      });
      throw error;
    }
  }
}
```

### 2. Data Loading Hooks

The `useDataLoading` hook provides a standardized way to fetch data with caching, loading states, error handling, and retry mechanisms.

#### Basic Usage

```typescript
import { useDataLoading } from './hooks/useDataLoading';

function MyComponent() {
  const { data, loading, error, retry } = useDataLoading(
    'my-data-key',
    fetchMyData,
    {
      retryCount: 3,
      retryDelay: 1000,
      cacheTime: 300000 // 5 minutes
    }
  );

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} onRetry={retry} />;
  
  return <DataDisplay data={data} />;
}
```

#### Specialized Hooks

```typescript
// Agenda data hook
const { agendaData, loading, error } = useAgendaData();

// Attendee data hook
const { attendeeData, loading, error } = useAttendeeData();
```

### 3. UI State Management Hooks

The `useUIState` hook provides reusable UI state management with validation, persistence, and error handling.

#### Basic Usage

```typescript
import { useUIState } from './hooks/useUIState';

function MyForm() {
  const { state, updateState, isValid, error, validateState } = useUIState(
    { name: '', email: '' },
    {
      validate: (state) => {
        if (!state.name) return 'Name is required';
        if (!state.email) return 'Email is required';
        if (!state.email.includes('@')) return 'Invalid email';
        return true;
      },
      persist: true,
      storageKey: 'my-form-state'
    }
  );

  return (
    <form>
      <input
        value={state.name}
        onChange={(e) => updateState({ name: e.target.value })}
        className={!isValid ? 'error' : ''}
      />
      {error && <div className="error-message">{error}</div>}
    </form>
  );
}
```

#### Specialized Hooks

```typescript
// Form state hook
const { values, errors, touched, setValue, setError } = useFormState({
  initialValues: { name: '', email: '' },
  validation: myValidationSchema
});

// Toggle state hook
const { isOpen, toggle, setOpen } = useToggleState(false, {
  persist: true,
  storageKey: 'sidebar-open'
});
```

### 4. Error Handling

The `ErrorHandlingService` provides centralized error handling and recovery patterns.

#### Usage Examples

```typescript
import { ErrorHandlingService } from './services/errorHandlingService';

// Cache errors
try {
  await unifiedCacheService.set('key', data);
} catch (error) {
  ErrorHandlingService.handleCacheError(error, {
    component: 'MyComponent',
    action: 'cacheData'
  });
}

// Network errors with retry
try {
  const data = await fetchData();
} catch (error) {
  await ErrorHandlingService.handleServiceError(error, {
    component: 'MyComponent',
    action: 'fetchData'
  }, {
    maxRetries: 3,
    retryDelay: 1000,
    fallbackAction: () => showOfflineMessage()
  });
}
```

### 5. Error Boundaries

The `ErrorBoundary` component catches JavaScript errors and displays a fallback UI.

#### Usage

```typescript
import ErrorBoundary from './components/ErrorBoundary';

function App() {
  return (
    <ErrorBoundary
      onError={(error, errorInfo) => {
        console.error('App error:', error, errorInfo);
        // Send to monitoring service
      }}
    >
      <MyComponent />
    </ErrorBoundary>
  );
}
```

## Best Practices

### 1. Service Integration

- Always use `unifiedCacheService` for cache operations
- Never access `localStorage` directly in service classes
- Use `ErrorHandlingService` for error handling
- Implement proper error recovery patterns

### 2. Hook Usage

- Use specialized hooks when available (`useAgendaData`, `useAttendeeData`)
- Implement proper validation in `useUIState`
- Use persistence for important UI state
- Handle loading and error states properly

### 3. Error Handling

- Wrap components in `ErrorBoundary` for critical sections
- Use appropriate error handling methods for different error types
- Implement retry logic for transient errors
- Provide user-friendly error messages

### 4. Performance

- Use `React.memo` for frequently re-rendering components
- Implement lazy loading for large components
- Use debouncing for validation and API calls
- Monitor cache performance and health

## Troubleshooting

### Common Issues

#### 1. Cache Data Disappearing

**Symptoms:** Data appears to be lost after login or page refresh

**Causes:**
- Inconsistent cache key formats
- Direct `localStorage` access bypassing unified cache
- Cache versioning conflicts

**Solutions:**
- Ensure all services use `unifiedCacheService`
- Check cache key consistency
- Verify cache versioning is working

#### 2. Validation Not Working

**Symptoms:** `useUIState` validation not triggering

**Causes:**
- Debounce timing issues
- Validation function not returning proper values
- State updates not triggering validation

**Solutions:**
- Check debounce settings
- Ensure validation returns `true`, `false`, or error string
- Use `validateState()` method for immediate validation

#### 3. Integration Test Failures

**Symptoms:** Tests failing with undefined values

**Causes:**
- Mock setup issues
- Service method not properly mocked
- Console output suppression

**Solutions:**
- Check mock configurations
- Ensure service methods are properly mocked
- Enable console output for debugging

### Debug Tools

#### 1. Cache Health Monitoring

```typescript
const health = await unifiedCacheService.getHealthStatus();
console.log('Cache health:', health);
```

#### 2. Error Statistics

```typescript
const stats = errorHandlingService.getErrorStats();
console.log('Error stats:', stats);
```

#### 3. State Debugging

```typescript
// In useUIState hook
console.log('Current state:', state);
console.log('Validation result:', validationResult);
console.log('Is valid:', isValid);
```

## Migration Guide

### From Direct localStorage Access

```typescript
// Old way
const data = localStorage.getItem('key');
localStorage.setItem('key', JSON.stringify(data));

// New way
const data = await unifiedCacheService.get('key');
await unifiedCacheService.set('key', data);
```

### From Custom State Management

```typescript
// Old way
const [state, setState] = useState(initialState);
const [isValid, setIsValid] = useState(true);

// New way
const { state, updateState, isValid, error } = useUIState(initialState, {
  validate: myValidationFunction
});
```

### From Custom Error Handling

```typescript
// Old way
try {
  await someOperation();
} catch (error) {
  console.error(error);
  showError(error.message);
}

// New way
try {
  await someOperation();
} catch (error) {
  ErrorHandlingService.handleServiceError(error, {
    component: 'MyComponent',
    action: 'someOperation'
  });
}
```

## Testing

### Unit Tests

```typescript
import { renderHook, act } from '@testing-library/react';
import { useUIState } from './hooks/useUIState';

test('should validate state correctly', () => {
  const { result } = renderHook(() => useUIState(
    { value: '' },
    {
      validate: (state) => state.value ? true : 'Value required',
      debounceMs: 0
    }
  ));

  act(() => {
    result.current.updateState({ value: 'test' });
  });

  expect(result.current.isValid).toBe(true);
});
```

### Integration Tests

```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { useDataLoading } from './hooks/useDataLoading';

test('should load data with caching', async () => {
  const mockFetch = vi.fn().mockResolvedValue({ data: 'test' });
  
  const { result } = renderHook(() => useDataLoading(
    'test-key',
    mockFetch
  ));

  await waitFor(() => {
    expect(result.current.data).toEqual({ data: 'test' });
  });
});
```

## Performance Monitoring

### Cache Performance

```typescript
// Monitor cache hit rates
const health = await unifiedCacheService.getHealthStatus();
console.log('Cache hit rate:', health.cacheHitRate);
console.log('Cache miss rate:', health.cacheMissRate);
```

### Error Monitoring

```typescript
// Monitor error rates
const stats = errorHandlingService.getErrorStats();
console.log('Total errors:', stats.totalErrors);
console.log('Error categories:', stats.errorCategories);
```

## Conclusion

The 2.1 series implementation provides a robust foundation for state management and error handling in the application. By following the patterns and best practices outlined in this guide, developers can build reliable, maintainable, and performant features.

For additional support or questions, refer to the individual story documentation or contact the development team.
