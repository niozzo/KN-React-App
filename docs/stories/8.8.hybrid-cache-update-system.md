# Story 8.8: Hybrid Cache Update System with Version-Based Detection

## Status
Draft

## Story
**As an** admin,  
**I want** to trigger cache updates via a button on a dedicated card that propagates instantly to active users and automatically catches up inactive users via lightweight polling,  
**so that** schedule changes are delivered efficiently without unnecessary bandwidth consumption while maintaining guaranteed eventual consistency.

## Acceptance Criteria

1. **Application Database Version Tracking**
   - Create `cache_update_triggers` table in Application Database with version tracking
   - Table includes: version (integer), triggered_at (timestamp)
   - Initial version starts at 1
   - Each admin trigger increments version by 1

2. **Admin UI Card for Cache Control**
   - Create new Card component on AdminPage showing cache status
   - Display current cache version number
   - Show "Last sync: X minutes ago" indicator
   - Include "Force Global Sync" button in the card
   - Show loading state during sync operation
   - Display success toast message after sync completes

3. **Service Worker Broadcast for Active Users**
   - When admin presses button, Service Worker broadcasts to all open tabs/windows
   - All active users receive update notification within 2 seconds
   - Active users automatically sync fresh data
   - Show toast notification "Schedule updated!" to users

4. **Lightweight Version-Based Polling**
   - Background process checks version every 5 minutes
   - Only fetches version number (~1KB) for comparison
   - If local version ‚â† server version: trigger full sync
   - If versions match: skip sync (no data download)
   - Update local version after successful sync

5. **Event-Based Version Checks**
   - Online event: Check version when user reconnects after being offline
   - Visibility change: Check version when user returns to app tab
   - App launch: Check version on app initialization
   - Each event compares local vs server version and syncs if different

6. **Version Management in Services**
   - Add `getCurrentCacheVersion()` method to `applicationDatabaseService`
   - Add `incrementCacheVersion()` method to `applicationDatabaseService`
   - Add `checkForMissedCacheUpdates()` method to `pwaDataSyncService`
   - Store local version in localStorage as `kn_cache_version`
   - Update local version after every successful sync

7. **Remove Heavy Polling**
   - Change `syncInterval` from 5 minutes to lightweight version-check mode
   - Polling now only checks version, not data
   - Full data sync only triggered when version mismatch detected
   - 99% reduction in polling bandwidth

8. **Simplified Audit Trail**
   - Every admin-triggered update logged in `cache_update_triggers` table
   - Can query history of all cache triggers
   - Includes timestamp and version number only
   - Useful for debugging "what version should users have?"

9. **Database Modification Guardrails** üö®
   - **Application DB** (`applicationDatabaseService`, `TABLE_MAPPINGS.application`): ‚úÖ CAN modify
     - Can add `cache_update_triggers` table
     - Can add new query methods to `applicationDatabaseService`
     - Uses existing `applicationDatabaseService.getClient()`
     - Safe to modify - we control this database
   - **Main DB / External DB** (`TABLE_MAPPINGS.main`, conference data): ‚ùå CANNOT touch
     - NO modifications to Main DB connection code
     - NO changes to how Main DB data is fetched
     - NO modifications to existing `pwaDataSyncService.syncAllData()` implementation
     - Only add conditional logic BEFORE calling existing sync methods
   - Only change WHEN we fetch data, not HOW we connect or fetch

10. **Backward Compatibility**
    - Existing sync mechanisms continue to work
    - Login/logout still provides fresh data
    - No breaking changes to current cache architecture
    - All existing event listeners remain functional

## Tasks / Subtasks

- [ ] Task 1: Create Application Database Table (AC: 1, 8)
  - [ ] Write SQL migration for `cache_update_triggers` table (version, triggered_at only)
  - [ ] Add initial version record (version = 1)
  - [ ] Create index on version column for fast lookups
  - [ ] Add table to `tableMappings.ts`
  - [ ] Verify table works with existing Application DB connection

- [ ] Task 2: Implement Application Database Service Methods (AC: 6, 9)
  - [ ] Add `getCurrentCacheVersion()` method - reuses existing client
  - [ ] Add `incrementCacheVersion()` method - reuses existing client
  - [ ] Use existing retry logic from applicationDatabaseService
  - [ ] Use existing error handling patterns
  - [ ] NO new connection code - only new query methods

- [ ] Task 3: Enhance PWA Data Sync Service (AC: 4, 5, 6, 7, 9)
  - [ ] Add `checkForMissedCacheUpdates()` private method
  - [ ] Modify `handleOnlineEvent()` to check version BEFORE calling existing syncAllData()
  - [ ] Modify `handleVisibilityChange()` to check version BEFORE sync
  - [ ] Modify `startPeriodicSync()` to check version first, then call existing syncAllData()
  - [ ] Update `syncAllData()` to store version in localStorage after successful sync
  - [ ] CRITICAL: Only add version check logic - don't modify sync mechanism itself
  - [ ] NO changes to how data is fetched, only when

- [ ] Task 4: Implement Service Worker Broadcast (AC: 3)
  - [ ] Add message handler in `public/sw.js` for ADMIN_CACHE_UPDATE_BROADCAST
  - [ ] Implement `clients.matchAll()` to find all open tabs
  - [ ] Send message to all clients when receiving admin broadcast
  - [ ] Add message listener in main app (App.tsx or pwaDataSyncService)
  - [ ] Call existing syncAllData() when broadcast received
  - [ ] Show toast notification "Schedule updated!" using existing toast system

- [ ] Task 5: Create Admin Cache Control Card (AC: 2)
  - [ ] Create new Card component in AdminPage showing cache status
  - [ ] Display current cache version from `getCurrentCacheVersion()`
  - [ ] Show "Last sync" timestamp
  - [ ] Move "Force Global Sync" button into this card
  - [ ] Call `incrementCacheVersion()` in handleForceGlobalSync
  - [ ] Call existing `pwaDataSyncService.clearCache()` and `forceSync()`
  - [ ] Trigger Service Worker broadcast after sync
  - [ ] Show success toast message "Cache updated to version X"
  - [ ] Add loading state during operation

- [ ] Task 6: Update Configuration (AC: 7)
  - [ ] Keep `syncInterval` at 5 minutes (but now does version check first)
  - [ ] Update cache config comments to reflect version-check-first behavior
  - [ ] Verify all existing event listeners remain unchanged

- [ ] Task 7: Pragmatic Testing (AC: 9, 10)
  - [ ] Manual test: Admin button increments version and syncs
  - [ ] Manual test: Open 2 tabs, trigger from one, verify other updates
  - [ ] Manual test: Go offline, admin triggers, reconnect - should sync
  - [ ] Manual test: Version check in console shows correct behavior
  - [ ] Verify existing tests still pass (no breaking changes)
  - [ ] Add unit test for `getCurrentCacheVersion()` method only
  - [ ] NO extensive new test suite - rely on existing test coverage

- [ ] Task 8: Documentation (AC: 8)
  - [ ] Add inline code comments explaining version check logic
  - [ ] Document new service methods (JSDoc comments)
  - [ ] Add console logging for version checks and updates
  - [ ] Update story with completion notes

## Dev Notes

### üö® CRITICAL ARCHITECTURAL CONSTRAINT üö®
**DATABASE MODIFICATION GUARDRAILS**
- We are close to launch - Main DB/External DB connections have been unstable

**‚úÖ Application DB (`applicationDatabaseService`, `TABLE_MAPPINGS.application`) - CAN modify:**
- Add new `cache_update_triggers` table to Application DB
- Add new query methods: `getCurrentCacheVersion()`, `incrementCacheVersion()`
- Use existing client: `applicationDatabaseService.getClient()`
- This is safe - we control this database

**‚ùå Main DB / External DB (`TABLE_MAPPINGS.main`, conference data) - CANNOT touch:**
- NO modifications to Main DB connection code
- NO changes to how Main DB data is fetched
- NO modifications to `pwaDataSyncService.syncAllData()` implementation
- Only add conditional checks BEFORE calling existing sync
- This story ONLY changes WHEN we sync from Main DB, not HOW we sync

**What we're adding:**
- Version check queries (Application DB only)
- Conditional logic (if version changed, THEN call existing `pwaDataSyncService.syncAllData()`)
- localStorage version storage (no DB connection)

### Architecture Context
This story implements a hybrid cache update system that combines:
1. **Instant updates** for active users (Service Worker broadcast)
2. **Lightweight polling** for safety net (version checks every 5 min)
3. **Event-based triggers** (online, visibility, app launch)
4. **Version-based change detection** (only sync when version changes)

### Key Design Decisions
- **Version number approach**: Simple integer comparison is faster and more reliable than timestamp comparison
- **Application Database storage**: Leverages existing infrastructure, gets cached with other metadata
- **Service Worker broadcast**: Only reaches currently-open tabs, but provides instant updates
- **Lightweight polling retained**: Provides safety net for edge cases with minimal overhead
- **Simplified tracking**: No "who triggered" field - single admin assumption
- **Toast notifications**: Provide user feedback for updates

### Source Tree References
**Files to Modify:**
- `src/services/applicationDatabaseService.ts` - Add version methods
- `src/services/pwaDataSyncService.ts` - Add version checking, modify event handlers
- `src/components/AdminPage.tsx` - Enhance button, show version
- `src/config/tableMappings.ts` - Add cache_update_triggers table
- `public/sw.js` - Add broadcast message handling

**Files to Create:**
- SQL migration: `add-cache-update-triggers-table.sql`

### Dependencies
- Existing `pwaDataSyncService` with event listeners
- Existing `applicationDatabaseService` with Supabase client
- Existing Service Worker infrastructure
- Existing admin "Force Global Sync" button

### Related Stories
- Story 2.2.3: Admin Force Global Sync (existing button we're enhancing)
- Story 1.2: Database Integration (Application DB infrastructure)
- Story 1.3: PWA Polish (Service Worker foundation)

### Testing

**Pragmatic Testing Approach:**
- Focus on manual testing (close to launch, minimize test suite changes)
- Verify existing tests still pass (no breaking changes)
- Add minimal unit test coverage for new version methods only

**Manual Test Scenarios:**
1. Admin button increments version ‚Üí Check console/network tab
2. Open 2 browser tabs ‚Üí Click button in one ‚Üí Other updates
3. Go offline ‚Üí Admin triggers ‚Üí Reconnect ‚Üí Should sync
4. Check console logs for version comparison logic
5. Verify toast notifications appear for users
6. Confirm existing login/logout flow unaffected

**Minimal Unit Tests:**
- Add test for `getCurrentCacheVersion()` - mocks existing client
- Add test for `incrementCacheVersion()` - mocks existing client
- Use existing test patterns from `applicationDatabaseService.test.ts`

**NO extensive new test suite** - rely on existing comprehensive test coverage

### Performance Considerations
- Version check is ~1KB request vs ~100KB full sync
- 99% reduction in polling bandwidth
- Service Worker broadcast has millisecond latency
- localStorage reads are instantaneous
- Database version query should use index for speed

### Security Considerations
- Version table uses existing RLS policies
- Admin users can increment version (write)
- All users can read version (read)
- No sensitive data in version table
- Audit trail helps with security forensics

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-13 | 1.0 | Initial story creation for hybrid cache update system | Sarah (PO) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be recorded during implementation*

### Debug Log References
*To be recorded during implementation*

### Completion Notes List
*To be recorded during implementation*

### File List
*To be recorded during implementation*

## QA Results
*Results from QA Agent review of the completed story implementation*

