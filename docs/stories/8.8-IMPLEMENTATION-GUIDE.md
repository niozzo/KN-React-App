# Story 8.8: Implementation Guide - Hybrid Cache Update System

## üö® CRITICAL: DATABASE MODIFICATION GUARDRAILS üö®

This implementation ONLY changes **WHEN** we sync data, not **HOW** we connect to databases.

### Two Separate Databases

**‚úÖ Application DB (`applicationDatabaseService`, `TABLE_MAPPINGS.application`) - CAN modify:**
- This is OUR controlled database for app-specific data
- We CAN add new tables (`cache_update_triggers`)
- We CAN add new query methods
- Uses existing `applicationDatabaseService.getClient()` (already stable)

**‚ùå Main DB / External DB (`TABLE_MAPPINGS.main`, conference data) - CANNOT touch:**
- This is the external conference data database
- NO modifications to Main DB connection code
- NO changes to how Main DB data is fetched
- Only add conditional checks BEFORE calling existing sync methods

### What We're Doing
- Adding version table to **Application DB** (safe to modify)
- Adding version check logic
- Lightweight polling checks version (1KB) instead of downloading all conference data (100KB)
- Admin presses button ‚Üí version increments in Application DB ‚Üí users detect change ‚Üí sync from **Main DB** using existing code

### What We're NOT Doing
- ‚ùå NO modifications to Main DB connection code
- ‚ùå NO changes to how Main DB data is fetched
- ‚ùå NO new Main DB connection mechanisms
- ‚ùå NO touching `pwaDataSyncService.syncAllData()` implementation (only add conditional checks before calling it)

---

## Implementation Steps

### Step 1: Create Database Table
Run `add-cache-update-triggers-table.sql` in Application Database

```sql
-- Simple table with just version and timestamp
CREATE TABLE cache_update_triggers (
  id SERIAL PRIMARY KEY,
  version INTEGER NOT NULL UNIQUE,
  triggered_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### Step 2: Add Version Methods to Application Database Service

```typescript
// In applicationDatabaseService.ts
// Uses EXISTING client - don't create new one!

async getCurrentCacheVersion(): Promise<{ version: number; triggeredAt: string }> {
  const client = this.getClient(); // EXISTING method
  const { data, error } = await client
    .from('cache_update_triggers')
    .select('version, triggered_at')
    .order('version', { ascending: false })
    .limit(1)
    .single();
  
  if (error) {
    console.warn('‚ö†Ô∏è Could not fetch cache version:', error);
    return { version: 0, triggeredAt: new Date().toISOString() };
  }
  
  return {
    version: data.version,
    triggeredAt: data.triggered_at
  };
}

async incrementCacheVersion(): Promise<number> {
  const adminClient = this.getAdminClient(); // EXISTING method
  
  // Get current max version
  const { data: current } = await adminClient
    .from('cache_update_triggers')
    .select('version')
    .order('version', { ascending: false })
    .limit(1)
    .single();
  
  const newVersion = (current?.version || 0) + 1;
  
  // Insert new version
  const { error } = await adminClient
    .from('cache_update_triggers')
    .insert({
      version: newVersion,
      triggered_at: new Date().toISOString()
    });
  
  if (error) throw error;
  
  console.log(`üì¶ Cache version incremented: ${current?.version || 0} ‚Üí ${newVersion}`);
  return newVersion;
}
```

### Step 3: Add Version Check to PWA Data Sync Service

```typescript
// In pwaDataSyncService.ts

private async checkForMissedCacheUpdates(): Promise<boolean> {
  try {
    // Get server version from Application DB
    const serverVersion = await applicationDb.getCurrentCacheVersion();
    
    // Get local version from localStorage
    const myVersion = parseInt(localStorage.getItem('kn_cache_version') || '0', 10);
    
    console.log(`üîç Cache version check: local=${myVersion}, server=${serverVersion.version}`);
    
    // If server version is newer, we need to update
    if (serverVersion.version > myVersion) {
      console.log(`üì° New cache version available: ${myVersion} ‚Üí ${serverVersion.version}`);
      // Update local version after sync
      localStorage.setItem('kn_cache_version', serverVersion.version.toString());
      return true;
    }
    
    return false;
  } catch (error) {
    console.warn('‚ö†Ô∏è Could not check cache version:', error);
    // On error, refresh to be safe
    return true;
  }
}

// Modify EXISTING event handlers - don't replace them!
private handleOnlineEvent = async () => {
  console.log('üåê Client reconnected - checking for missed updates');
  this.setOnlineStatus(true);
  
  if (this.isUserAuthenticated()) {
    const needsUpdate = await this.checkForMissedCacheUpdates();
    
    if (needsUpdate) {
      console.log('üì• Missed update detected - syncing');
      await this.syncAllData(); // EXISTING method - don't modify!
    } else {
      console.log('‚úÖ Cache is current');
    }
  }
};

// Similar for handleVisibilityChange and startPeriodicSync
```

### Step 4: Service Worker Broadcast

```typescript
// In public/sw.js

self.addEventListener('message', async (event) => {
  if (event.data && event.data.type === 'ADMIN_CACHE_UPDATE') {
    console.log('üì¢ Broadcasting cache update to all clients');
    
    const clients = await self.clients.matchAll({ 
      type: 'window',
      includeUncontrolled: true 
    });
    
    clients.forEach(client => {
      client.postMessage({
        type: 'CACHE_UPDATE_BROADCAST',
        version: event.data.version,
        timestamp: event.data.timestamp
      });
    });
  }
});

// In App.tsx or pwaDataSyncService.ts
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.addEventListener('message', async (event) => {
    if (event.data.type === 'CACHE_UPDATE_BROADCAST') {
      console.log('üì• Received admin update broadcast - syncing!');
      await pwaDataSyncService.syncAllData(); // EXISTING method
      
      // Show toast notification
      showToast('Schedule updated!', 'info');
    }
  });
}
```

### Step 5: Create Admin Cache Control Card

```tsx
// In AdminPage.tsx - add new card

const CacheControlCard: React.FC = () => {
  const [cacheVersion, setCacheVersion] = useState<number>(0);
  const [lastSync, setLastSync] = useState<string>('');
  const [syncing, setSyncing] = useState(false);
  
  useEffect(() => {
    loadCacheVersion();
  }, []);
  
  const loadCacheVersion = async () => {
    const { version, triggeredAt } = await applicationDb.getCurrentCacheVersion();
    setCacheVersion(version);
    setLastSync(triggeredAt);
  };
  
  const handleForceSync = async () => {
    setSyncing(true);
    try {
      // 1. Increment version in DB
      const newVersion = await applicationDb.incrementCacheVersion();
      
      // 2. Clear and sync cache (EXISTING methods)
      await pwaDataSyncService.clearCache();
      await pwaDataSyncService.forceSync();
      
      // 3. Broadcast to all active users
      if ('serviceWorker' in navigator) {
        const registration = await navigator.serviceWorker.ready;
        registration.active?.postMessage({
          type: 'ADMIN_CACHE_UPDATE',
          version: newVersion,
          timestamp: Date.now()
        });
      }
      
      // 4. Show success toast
      showToast(`Cache updated to version ${newVersion}`, 'success');
      
      // 5. Reload version display
      await loadCacheVersion();
      
    } catch (error) {
      console.error('Failed to sync cache:', error);
      showToast('Cache sync failed', 'error');
    } finally {
      setSyncing(false);
    }
  };
  
  return (
    <Card>
      <CardContent>
        <Typography variant="h6">Cache Control</Typography>
        <Box sx={{ mt: 2 }}>
          <Chip label={`Version ${cacheVersion}`} color="primary" sx={{ mr: 1 }} />
          <Typography variant="caption" color="text.secondary">
            Last updated: {formatDistanceToNow(new Date(lastSync))} ago
          </Typography>
        </Box>
        <Button
          variant="contained"
          color="primary"
          onClick={handleForceSync}
          disabled={syncing}
          startIcon={syncing ? <CircularProgress size={20} /> : <SyncIcon />}
          sx={{ mt: 2 }}
          fullWidth
        >
          {syncing ? 'Syncing...' : 'Force Global Sync'}
        </Button>
      </CardContent>
    </Card>
  );
};
```

### Step 6: Update Table Mappings

```typescript
// In src/config/tableMappings.ts
export const TABLE_MAPPINGS = {
  application: {
    speaker_assignments: 'speaker_assignments',
    agenda_item_metadata: 'agenda_item_metadata',
    attendee_metadata: 'attendee_metadata',
    dining_item_metadata: 'dining_item_metadata',
    cache_update_triggers: 'cache_update_triggers'  // ADD THIS LINE
  },
  main: {
    // ... unchanged
  }
};
```

---

## Testing Checklist

### Manual Tests (Primary)
- [ ] Admin clicks button ‚Üí Version increments in DB
- [ ] Open 2 tabs ‚Üí Click button in tab 1 ‚Üí Tab 2 updates within 2 seconds
- [ ] Go offline ‚Üí Admin triggers ‚Üí Reconnect ‚Üí Device syncs automatically
- [ ] Console logs show version comparisons
- [ ] Toast notifications appear for users
- [ ] Existing login/logout flow still works

### Unit Tests (Minimal)
- [ ] Test `getCurrentCacheVersion()` with mocked client
- [ ] Test `incrementCacheVersion()` with mocked client
- [ ] Verify existing tests still pass

---

## What Success Looks Like

1. **Admin Experience:**
   - Sees cache version in card on admin page
   - Clicks "Force Global Sync" button
   - Sees toast: "Cache updated to version X"
   - Button in a clean Card component

2. **Active User Experience:**
   - Admin triggers update
   - Within 2 seconds, user sees toast: "Schedule updated!"
   - Data refreshes automatically
   - No manual refresh needed

3. **Inactive User Experience:**
   - User was offline during update
   - Reconnects later
   - Device checks version (1KB request)
   - Detects mismatch, syncs full data (100KB)
   - User has latest data within 5-10 seconds of reconnection

4. **Network Impact:**
   - 99% reduction in polling bandwidth
   - Most checks = 1KB (version number)
   - Only download 100KB when actually needed

---

## Troubleshooting

### If users aren't getting updates:
1. Check console: Is version check happening?
2. Check localStorage: Is `kn_cache_version` being updated?
3. Check Service Worker: Are messages being broadcast?
4. Check admin: Did version actually increment in DB?

### If DB connection fails:
- **First: Identify which database is failing**
  - Application DB version query? ‚Üí Check Application DB only (safe to debug)
  - Main DB / External DB sync? ‚Üí Don't touch Main DB connection code!
- **Application DB issues (`applicationDatabaseService`, `TABLE_MAPPINGS.application`):**
  - Check `cache_update_triggers` table exists in Application DB
  - Check table is in `tableMappings.ts` under `application` section
  - Check `applicationDatabaseService.getClient()` works
  - Safe to add logging/debugging here - we control this DB
- **Main DB issues (`TABLE_MAPPINGS.main`, conference data):**
  - Don't modify Main DB connection code
  - Check if existing `syncAllData()` still works without your changes
  - If Main DB sync worked before your changes, problem is in conditional logic only

---

## Key Architectural Principles

1. ‚úÖ **Two databases, different rules:**
   - **Application DB** (`applicationDatabaseService`, `TABLE_MAPPINGS.application`): CAN add tables and methods (we control it)
   - **Main DB / External DB** (`TABLE_MAPPINGS.main`, conference data): CANNOT touch connection code (external, unstable)
2. ‚úÖ **Reuse existing clients** - use `applicationDatabaseService.getClient()` for Application DB version queries
3. ‚úÖ **Add conditional logic** - check version in Application DB, THEN call existing `pwaDataSyncService.syncAllData()` for Main DB
4. ‚úÖ **Fail safe** - if version check fails, sync from Main DB anyway
5. ‚úÖ **Backward compatible** - all existing Main DB sync flows still work unchanged
6. ‚úÖ **Toast notifications** - user feedback is required
7. ‚úÖ **Simplified** - no "who triggered" tracking needed

---

## Success Metrics

- Admin can trigger updates with one button click
- Active users receive updates in < 2 seconds
- Inactive users catch up within 5-10 seconds of reconnection
- 99% reduction in polling bandwidth (version check = 1KB vs full sync = 100KB)
- **Application DB** (`applicationDatabaseService`, `TABLE_MAPPINGS.application`): Successfully added `cache_update_triggers` table and version methods
- **Main DB / External DB** (`TABLE_MAPPINGS.main`): Zero changes to connection code or sync implementation
- All existing tests still pass

