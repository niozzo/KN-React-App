# Story 3.4: Dining Event Table Companions Widget

**Status:** Ready for Development  
**Priority:** Medium  
**Epic:** Networking & Social Features  
**Estimated Effort:** 1 Story (Simplified Implementation)

## User Story

As an **event attendee**,  
I want to **see who I'm sitting with at dining events** in an expandable widget,  
So that **I can connect with my table companions before the event and plan my networking**.

## Story Context

**Existing System Integration:**
- Integrates with: Existing dining events display, seat assignments system, localStorage-first architecture
- Technology: React components, direct main DB queries, existing cache management patterns
- Follows pattern: localStorage-first data access, client-side caching, PWA architecture
- Touch points: Dining events page, seat assignments data, existing data services

## Acceptance Criteria

### **Story 3.4.1: Simplified Table Companions Implementation**

**Core Requirement:**
Implement a simple, direct approach using client-side queries to the main database with localStorage caching for table companions data.

**Implementation Strategy:**
Use a **direct database query approach** that queries the main database directly from the client, caches results in localStorage, and displays table companions in an expandable widget. This eliminates the need for server-side processing, Application DB, and complex synchronization.

**Functional Requirements:**
1. **Direct DB Query**: Query `seat_assignments` table directly from client for table companions
2. **localStorage Caching**: Cache table companions data in localStorage for performance
3. **Expandable Widget**: Collapsed state shows "Who am I sitting with?" with expand/collapse functionality
4. **Table Companions Display**: Expanded state shows list of all table companions with names, companies, photos
5. **Company Name Display**: Company names displayed as standardized company names (not raw company field)
6. **Profile Links**: Names displayed as hyperlinks using existing profile navigation patterns from sponsors page
7. **Real-time Updates**: Widget updates when seat assignments change (via cache refresh)
8. **Offline Capability**: Widget works offline using cached table companions data

**Technical Requirements:**
1. **Client-Side Query**: Direct Supabase query to `seat_assignments` table (READ-ONLY)
2. **Cache Management**: localStorage caching with cache keys for table companions
3. **Data Transformation**: Client-side processing of seat assignments to table companions
4. **Profile Integration**: Reuse existing profile navigation components from sponsors page
5. **Company Standardization**: Use standardized company names from existing data transformation
6. **Error Handling**: Graceful fallback when data unavailable or network issues
7. **Performance**: Widget loads in < 200ms from localStorage cache
8. **Responsive Design**: Widget works on mobile, tablet, and desktop
9. **Accessibility**: Widget meets WCAG 2.1 AA standards

**Success Criteria:**
- [ ] Direct database query implemented and working
- [ ] localStorage caching implemented with proper cache keys
- [ ] Expandable widget implemented and functional
- [ ] Table companions display working correctly
- [ ] Company names displayed as standardized company names
- [ ] Names displayed as hyperlinks using existing profile navigation components
- [ ] Profile navigation working correctly (reusing sponsors page patterns)
- [ ] Cache refresh updates widget automatically
- [ ] Offline capability verified
- [ ] Integration with dining events page complete
- [ ] Performance requirements met (< 200ms load time)
- [ ] Responsive design verified
- [ ] Accessibility standards met
- [ ] Error handling implemented with graceful fallbacks

## Technical Implementation Plan

### **Simplified Implementation Approach**

**Direct Database Query Service:**
```typescript
// New service: tableCompanionsService.ts
export class TableCompanionsService {
  async getTableCompanions(tableName: string, diningEventId: string): Promise<TableCompanion[]> {
    const cacheKey = `table_companions_${tableName}_${diningEventId}`;
    
    // Check localStorage cache first
    const cached = localStorage.getItem(cacheKey);
    if (cached) {
      const data = JSON.parse(cached);
      if (this.isCacheValid(data)) {
        return data.companions;
      }
    }
    
    // Query main database directly (READ-ONLY)
    const { data: seatAssignments, error } = await supabase
      .from('seat_assignments')
      .select(`
        attendee_id,
        attendee_first_name,
        attendee_last_name,
        seat_number,
        assignment_type
      `)
      .eq('table_name', tableName)
      .eq('dining_event_id', diningEventId);
    
    if (error) throw error;
    
    // Transform to table companions
    const companions = seatAssignments.map(assignment => ({
      attendee_id: assignment.attendee_id,
      first_name: assignment.attendee_first_name,
      last_name: assignment.attendee_last_name,
      seat_number: assignment.seat_number,
      assignment_type: assignment.assignment_type
    }));
    
    // Cache results
    localStorage.setItem(cacheKey, JSON.stringify({
      companions,
      cached_at: Date.now(),
      expires_at: Date.now() + (5 * 60 * 1000) // 5 minutes
    }));
    
    return companions;
  }
  
  private isCacheValid(data: any): boolean {
    return data.expires_at > Date.now();
  }
}
```

**React Component Implementation:**
```typescript
interface TableCompanionsWidgetProps {
  diningEventId: string;
  tableName: string;
  attendeeId: string;
}

export const TableCompanionsWidget: React.FC<TableCompanionsWidgetProps> = ({
  diningEventId,
  tableName,
  attendeeId
}) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [companions, setCompanions] = useState<TableCompanion[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const loadCompanions = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const service = new TableCompanionsService();
      const data = await service.getTableCompanions(tableName, diningEventId);
      
      // Filter out current attendee
      const otherCompanions = data.filter(c => c.attendee_id !== attendeeId);
      setCompanions(otherCompanions);
    } catch (err) {
      setError('Failed to load table companions');
      console.error('Table companions error:', err);
    } finally {
      setIsLoading(false);
    }
  };
  
  const toggleExpanded = () => {
    if (!isExpanded && companions.length === 0) {
      loadCompanions();
    }
    setIsExpanded(!isExpanded);
  };
  
  return (
    <div className="table-companions-widget">
      <button 
        onClick={toggleExpanded}
        className="companions-toggle"
        aria-expanded={isExpanded}
      >
        {isLoading ? 'Loading...' : 'Who am I sitting with?'}
      </button>
      
      {isExpanded && (
        <div className="companions-list">
          {error ? (
            <div className="error">Unable to load companions</div>
          ) : (
            companions.map(companion => (
              <div key={companion.attendee_id} className="companion">
                <ProfileLink 
                  attendeeId={companion.attendee_id}
                  name={`${companion.first_name} ${companion.last_name}`}
                />
                <span className="seat">Seat {companion.seat_number}</span>
              </div>
            ))
          )}
        </div>
      )}
    </div>
  );
};
```

## Definition of Done

### **Simplified Implementation (Story 3.4.1)**
- [ ] Direct database query service implemented and working
- [ ] localStorage caching implemented with proper cache keys
- [ ] Expandable widget implemented and functional
- [ ] Table companions display working correctly
- [ ] Company names displayed as standardized company names
- [ ] Names displayed as hyperlinks using existing profile navigation components
- [ ] Profile navigation working correctly (reusing sponsors page patterns)
- [ ] Cache refresh updates widget automatically
- [ ] Offline capability verified
- [ ] Integration with dining events page complete
- [ ] Performance requirements met (< 200ms load time)
- [ ] Responsive design verified
- [ ] Accessibility standards met
- [ ] Error handling implemented with graceful fallbacks
- [ ] Code follows existing patterns and standards
- [ ] Tests pass (existing and new)
- [ ] Documentation updated

## Risk Assessment

**Primary Risk:** Performance impact from direct database queries
**Mitigation:** localStorage caching reduces database load
**Secondary Risk:** Network issues affecting user experience
**Mitigation:** Offline capability with cached data
**Rollback:** Remove widget component and service

## Dependencies

- **Prerequisites:** Existing dining events functionality (Story 2.1g series)
- **Database Access:** Main database read-only access
- **Cache Management:** Existing localStorage-first architecture
- **Profile Navigation:** Existing profile link components from sponsors page

## Notes

- **Simplified Approach**: Direct client-side queries eliminate server-side complexity
- **Performance Focus**: localStorage caching for fast loading
- **Database Constraint**: Read-only main DB access only
- **Architecture Alignment**: Leverages existing localStorage-first patterns
