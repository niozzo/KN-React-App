# Story 2.1e2: Advanced Monitoring Dashboard

**Epic:** Epic 2 - Core PWA Functionality  
**Story ID:** 2.1e2  
**Priority:** MEDIUM  
**Story Points:** 3  
**Status:** Ready for Development  

## User Story

**As a** system administrator  
**I want** a visual dashboard to monitor cache performance and health  
**So that** I can quickly identify and resolve cache-related issues

## Problem Statement

While basic cache health monitoring exists, there's no visual interface to view cache metrics, performance data, or health status in real-time.

## Acceptance Criteria

### Primary Criteria
- [ ] Performance monitoring tracks cache efficiency
- [ ] Visual dashboard displays cache metrics
- [ ] Real-time health status updates
- [ ] Historical performance data available

### Technical Criteria
- [ ] Create cache health monitoring dashboard component
- [ ] Add performance metrics collection
- [ ] Implement real-time updates
- [ ] Add historical data storage

### Validation Criteria
- [ ] Performance metrics are accessible via dashboard
- [ ] Dashboard updates in real-time
- [ ] Historical data is stored and retrievable
- [ ] Dashboard is responsive and accessible

## Technical Implementation

### Files to Create/Modify
- `src/components/CacheHealthDashboard.tsx` - New monitoring dashboard
- `src/services/cacheMetricsService.ts` - New metrics collection service
- `src/hooks/useCacheMetrics.ts` - New metrics hook
- `src/services/cacheMonitoringService.ts` - Extend existing service

### Code Changes Required

#### 1. Cache Metrics Service
```typescript
// Create: src/services/cacheMetricsService.ts
export class CacheMetricsService {
  private metrics: CacheMetrics = {
    cacheHits: 0,
    cacheMisses: 0,
    cacheCorruptions: 0,
    syncFailures: 0,
    stateResets: 0,
    averageResponseTime: 0,
    totalDataSize: 0,
    lastUpdated: new Date().toISOString()
  };

  private historicalData: HistoricalMetric[] = [];

  recordCacheHit(responseTime: number, dataSize: number) {
    this.metrics.cacheHits++;
    this.updateAverageResponseTime(responseTime);
    this.metrics.totalDataSize += dataSize;
    this.metrics.lastUpdated = new Date().toISOString();
    this.storeHistoricalData('cache_hit', responseTime);
  }

  recordCacheMiss(reason: string) {
    this.metrics.cacheMisses++;
    this.metrics.lastUpdated = new Date().toISOString();
    this.storeHistoricalData('cache_miss', 0);
  }

  recordCacheCorruption(error: string) {
    this.metrics.cacheCorruptions++;
    this.metrics.lastUpdated = new Date().toISOString();
    this.storeHistoricalData('cache_corruption', 0);
  }

  getMetrics(): CacheMetrics {
    return { ...this.metrics };
  }

  getHistoricalData(hours: number = 24): HistoricalMetric[] {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000);
    return this.historicalData.filter(metric => 
      new Date(metric.timestamp) > cutoff
    );
  }

  private updateAverageResponseTime(responseTime: number) {
    const total = this.metrics.cacheHits + this.metrics.cacheMisses;
    this.metrics.averageResponseTime = 
      (this.metrics.averageResponseTime * (total - 1) + responseTime) / total;
  }

  private storeHistoricalData(type: string, value: number) {
    this.historicalData.push({
      type,
      value,
      timestamp: new Date().toISOString()
    });

    // Keep only last 7 days of data
    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    this.historicalData = this.historicalData.filter(metric =>
      new Date(metric.timestamp) > weekAgo
    );
  }
}
```

#### 2. Cache Health Dashboard Component
```typescript
// Create: src/components/CacheHealthDashboard.tsx
export const CacheHealthDashboard: React.FC = () => {
  const [metrics, setMetrics] = useState<CacheMetrics | null>(null);
  const [healthStatus, setHealthStatus] = useState('unknown');
  const [historicalData, setHistoricalData] = useState<HistoricalMetric[]>([]);
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    const interval = setInterval(() => {
      const currentMetrics = cacheMetricsService.getMetrics();
      const consistency = dataConsistencyService.validateCacheConsistency(
        getCachedData(), 
        getUIState()
      );
      
      setMetrics(currentMetrics);
      setHealthStatus(consistency.isConsistent ? 'healthy' : 'unhealthy');
      setHistoricalData(cacheMetricsService.getHistoricalData(24));
    }, 5000);

    return () => clearInterval(interval);
  }, []);

  if (!isVisible) {
    return (
      <button 
        className="cache-dashboard-toggle"
        onClick={() => setIsVisible(true)}
      >
        üìä Cache Health
      </button>
    );
  }

  return (
    <div className="cache-health-dashboard">
      <div className="dashboard-header">
        <h3>Cache Health Dashboard</h3>
        <button onClick={() => setIsVisible(false)}>√ó</button>
      </div>
      
      <div className="health-status">
        <div className={`status-indicator ${healthStatus}`}>
          {healthStatus === 'healthy' ? '‚úÖ' : '‚ùå'}
        </div>
        <span>Status: {healthStatus}</span>
      </div>

      <div className="metrics-grid">
        <div className="metric-card">
          <h4>Cache Performance</h4>
          <div>Hits: {metrics?.cacheHits || 0}</div>
          <div>Misses: {metrics?.cacheMisses || 0}</div>
          <div>Hit Rate: {calculateHitRate(metrics)}%</div>
        </div>

        <div className="metric-card">
          <h4>Response Time</h4>
          <div>Average: {metrics?.averageResponseTime?.toFixed(2)}ms</div>
          <div>Data Size: {formatBytes(metrics?.totalDataSize || 0)}</div>
        </div>

        <div className="metric-card">
          <h4>Issues</h4>
          <div>Corruptions: {metrics?.cacheCorruptions || 0}</div>
          <div>Sync Failures: {metrics?.syncFailures || 0}</div>
          <div>State Resets: {metrics?.stateResets || 0}</div>
        </div>
      </div>

      <div className="historical-chart">
        <h4>24-Hour Performance</h4>
        <CachePerformanceChart data={historicalData} />
      </div>
    </div>
  );
};
```

#### 3. Cache Metrics Hook
```typescript
// Create: src/hooks/useCacheMetrics.ts
export const useCacheMetrics = () => {
  const [metrics, setMetrics] = useState<CacheMetrics | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadMetrics = () => {
      const currentMetrics = cacheMetricsService.getMetrics();
      setMetrics(currentMetrics);
      setLoading(false);
    };

    loadMetrics();
    const interval = setInterval(loadMetrics, 5000);
    return () => clearInterval(interval);
  }, []);

  const refreshMetrics = useCallback(() => {
    setLoading(true);
    const currentMetrics = cacheMetricsService.getMetrics();
    setMetrics(currentMetrics);
    setLoading(false);
  }, []);

  return { metrics, loading, refreshMetrics };
};
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Cache health dashboard component created
- [ ] Performance metrics collection working
- [ ] Real-time updates functional
- [ ] Historical data storage implemented
- [ ] Dashboard is responsive and accessible
- [ ] Code review completed
- [ ] Documentation updated

## Testing Strategy

### Unit Tests
- Test metrics collection accuracy
- Test dashboard component rendering
- Test historical data storage

### Integration Tests
- Test dashboard integration with cache services
- Test real-time updates
- Test historical data retrieval

### Manual Testing
- Verify dashboard displays correct metrics
- Test real-time updates
- Verify historical data accuracy
- Test responsive design

## Dependencies

- **Blocks:** None
- **Depends on:** Story 2.1e1 (Core Cache Health Monitoring)
- **Related:** Story 2.1d (Comprehensive Logging)

## Notes

This story provides the visual interface for cache monitoring. It should be implemented after the core monitoring infrastructure is in place.

## Acceptance Test Scenarios

1. **Dashboard Display Test**: Dashboard shows current cache metrics
2. **Real-time Updates Test**: Dashboard updates every 5 seconds
3. **Historical Data Test**: Historical performance data is displayed
4. **Responsive Design Test**: Dashboard works on different screen sizes
5. **Accessibility Test**: Dashboard is accessible to screen readers

## Dashboard Features

- Real-time cache health status
- Performance metrics (hits, misses, response time)
- Issue tracking (corruptions, failures, resets)
- Historical performance charts
- Responsive design
- Toggle visibility for production use
