# Story 2.1e1: Core Cache Health Monitoring

**Epic:** Epic 2 - Core PWA Functionality  
**Story ID:** 2.1e1  
**Priority:** MEDIUM  
**Story Points:** 5  
**Status:** Ready for Development  

## User Story

**As a** system administrator  
**I want** basic cache health monitoring and validation  
**So that** I can detect and resolve cache issues proactively

## Problem Statement

Currently, there's no proactive monitoring of cache health or data consistency. Issues are only discovered when users report problems, making it difficult to prevent similar issues.

## Acceptance Criteria

### Primary Criteria
- [ ] Cache versioning prevents stale data issues
- [ ] TTL validation ensures cache freshness
- [ ] Data consistency checks validate cache vs UI state
- [ ] Error boundaries prevent UI crashes from cache issues

### Technical Criteria
- [ ] Implement cache versioning system
- [ ] Add TTL validation to cache entries
- [ ] Create data consistency validation service
- [ ] Implement error boundaries for cache failures

### Validation Criteria
- [ ] Cache entries have version numbers and expiration times
- [ ] Stale cache is automatically detected and refreshed
- [ ] Data inconsistencies are logged and resolved
- [ ] Cache failures don't crash the application

## Technical Implementation

### Files to Create/Modify
- `src/services/cacheVersioningService.ts` - New cache versioning service
- `src/services/dataConsistencyService.ts` - New consistency validation service
- `src/components/CacheErrorBoundary.tsx` - New error boundary component
- `src/services/pwaDataSyncService.ts` - Add TTL validation
- `src/services/agendaService.ts` - Integrate versioning

### Code Changes Required

#### 1. Cache Versioning System
```typescript
// Create: src/services/cacheVersioningService.ts
export class CacheVersioningService {
  private readonly CACHE_VERSION = '2.1.0';
  private readonly TTL_DEFAULT = 24 * 60 * 60 * 1000; // 24 hours

  createCacheEntry(data: any, ttl?: number): CacheEntry {
    return {
      data,
      version: this.CACHE_VERSION,
      timestamp: new Date().toISOString(),
      ttl: ttl || this.TTL_DEFAULT,
      checksum: this.calculateChecksum(data)
    };
  }

  validateCacheEntry(entry: CacheEntry): ValidationResult {
    const now = Date.now();
    const entryTime = new Date(entry.timestamp).getTime();
    const isExpired = (now - entryTime) > entry.ttl;
    const isVersionValid = entry.version === this.CACHE_VERSION;
    const isChecksumValid = entry.checksum === this.calculateChecksum(entry.data);

    return {
      isValid: !isExpired && isVersionValid && isChecksumValid,
      isExpired,
      isVersionValid,
      isChecksumValid,
      age: now - entryTime
    };
  }

  private calculateChecksum(data: any): string {
    return btoa(JSON.stringify(data)).slice(0, 16);
  }
}
```

#### 2. Data Consistency Validation
```typescript
// Create: src/services/dataConsistencyService.ts
export class DataConsistencyService {
  validateCacheConsistency(cacheData: any, uiState: any): ConsistencyReport {
    const issues: string[] = [];
    
    // Check if cache has data but UI shows empty
    if (cacheData && cacheData.length > 0 && (!uiState.sessions || uiState.sessions.length === 0)) {
      issues.push('Cache has data but UI shows empty state');
    }
    
    // Check if UI has data but cache is empty
    if ((!cacheData || cacheData.length === 0) && uiState.sessions && uiState.sessions.length > 0) {
      issues.push('UI has data but cache is empty');
    }
    
    // Check for future timestamps
    if (cacheData && cacheData.some((item: any) => new Date(item.timestamp) > new Date())) {
      issues.push('Cache contains future timestamps');
    }

    return {
      isConsistent: issues.length === 0,
      issues,
      timestamp: new Date().toISOString()
    };
  }
}
```

#### 3. Error Boundary Component
```typescript
// Create: src/components/CacheErrorBoundary.tsx
export class CacheErrorBoundary extends React.Component {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('ðŸš¨ Cache Error Boundary:', error, errorInfo);
    // Log to monitoring service
    this.logError(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="cache-error-fallback">
          <h2>Data Loading Issue</h2>
          <p>There was a problem loading your schedule data.</p>
          <button onClick={() => this.handleRetry()}>
            Retry
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Cache versioning system implemented and tested
- [ ] TTL validation working correctly
- [ ] Data consistency validation service created
- [ ] Error boundaries prevent UI crashes
- [ ] Code review completed
- [ ] Documentation updated

## Testing Strategy

### Unit Tests
- Test cache versioning with various data types
- Test TTL validation with different expiration times
- Test data consistency validation scenarios
- Test error boundary error handling

### Integration Tests
- Test cache versioning integration with existing services
- Test consistency validation during normal operation
- Test error boundary integration with cache failures

### Manual Testing
- Verify cache versioning prevents stale data
- Test TTL validation with expired cache
- Verify error boundary catches cache errors

## Dependencies

- **Blocks:** Story 2.1e2 (Advanced Monitoring Dashboard)
- **Depends on:** Story 2.1d (Comprehensive Logging)
- **Related:** Story 2.1c (Fix Cache Validation Logic)

## Notes

This story provides the core cache health monitoring infrastructure. It focuses on the essential monitoring capabilities without the complexity of a full dashboard.

## Acceptance Test Scenarios

1. **Cache Versioning Test**: Old cache versions are rejected and refreshed
2. **TTL Validation Test**: Expired cache entries are automatically refreshed
3. **Data Consistency Test**: Inconsistencies between cache and UI are detected
4. **Error Boundary Test**: Cache failures don't crash the application
