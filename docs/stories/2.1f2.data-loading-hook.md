# Story 2.1f2: Data Loading Hook

**Epic:** Epic 2 - Core PWA Functionality  
**Story ID:** 2.1f2  
**Priority:** LOW  
**Story Points:** 3  
**Status:** Ready for Development  

## User Story

**As a** developer  
**I want** a reusable data loading hook that handles caching and error states  
**So that** I can easily load data with consistent caching behavior across components

## Problem Statement

Currently, data loading logic is scattered across multiple hooks and components, leading to inconsistent caching behavior and duplicated error handling code.

## Acceptance Criteria

### Primary Criteria
- [ ] Reusable hook for data loading with caching
- [ ] Consistent error handling across all data loading
- [ ] Automatic cache management
- [ ] Loading state management

### Technical Criteria
- [ ] Create useDataLoading hook
- [ ] Integrate with unified cache service
- [ ] Add comprehensive error handling
- [ ] Implement loading state management

### Validation Criteria
- [ ] Hook can be used across different components
- [ ] Error handling is consistent
- [ ] Cache management is automatic
- [ ] Loading states are properly managed

## Technical Implementation

### Files to Create/Modify
- `src/hooks/useDataLoading.ts` - New data loading hook
- `src/hooks/useSessionData.js` - Refactor to use new hook
- `src/services/unifiedCacheService.ts` - Ensure compatibility

### Code Changes Required

#### 1. Data Loading Hook
```typescript
// Create: src/hooks/useDataLoading.ts
export interface LoadOptions {
  useCache?: boolean;
  cache?: boolean;
  ttl?: number;
  retries?: number;
  retryDelay?: number;
}

export interface DataLoadingState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  lastUpdated: Date | null;
  retryCount: number;
}

export const useDataLoading = <T>() => {
  const [state, setState] = useState<DataLoadingState<T>>({
    data: null,
    loading: false,
    error: null,
    lastUpdated: null,
    retryCount: 0
  });

  const unifiedCache = useMemo(() => new UnifiedCacheService(), []);

  const loadData = useCallback(async (
    key: string,
    fetcher: () => Promise<T>,
    options: LoadOptions = {}
  ): Promise<T | null> => {
    const {
      useCache = true,
      cache = true,
      ttl = 5 * 60 * 1000, // 5 minutes default
      retries = 3,
      retryDelay = 1000
    } = options;

    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      // Try cache first
      if (useCache) {
        const cached = await unifiedCache.get<T>(key);
        if (cached) {
          setState(prev => ({
            ...prev,
            data: cached,
            loading: false,
            lastUpdated: new Date(),
            retryCount: 0
          }));
          return cached;
        }
      }

      // Fetch from source
      const data = await fetcher();
      
      // Cache the result
      if (cache) {
        await unifiedCache.set(key, data, ttl);
      }

      setState(prev => ({
        ...prev,
        data,
        loading: false,
        lastUpdated: new Date(),
        retryCount: 0
      }));

      return data;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      
      setState(prev => ({
        ...prev,
        loading: false,
        error: errorMessage,
        retryCount: prev.retryCount + 1
      }));

      // Retry logic
      if (state.retryCount < retries) {
        setTimeout(() => {
          loadData(key, fetcher, options);
        }, retryDelay * Math.pow(2, state.retryCount)); // Exponential backoff
      }

      return null;
    }
  }, [unifiedCache, state.retryCount]);

  const refresh = useCallback(async (
    key: string,
    fetcher: () => Promise<T>,
    options: LoadOptions = {}
  ): Promise<T | null> => {
    // Force refresh by bypassing cache
    return loadData(key, fetcher, { ...options, useCache: false });
  }, [loadData]);

  const clearCache = useCallback(async (key: string) => {
    try {
      await unifiedCache.remove(key);
      setState(prev => ({ ...prev, data: null, lastUpdated: null }));
    } catch (error) {
      console.warn('Failed to clear cache:', error);
    }
  }, [unifiedCache]);

  const clearError = useCallback(() => {
    setState(prev => ({ ...prev, error: null, retryCount: 0 }));
  }, []);

  return {
    ...state,
    loadData,
    refresh,
    clearCache,
    clearError
  };
};
```

#### 2. Specialized Hooks
```typescript
// Create: src/hooks/useAgendaData.ts
export const useAgendaData = () => {
  const { data, loading, error, loadData, refresh, clearCache } = useDataLoading<PaginatedResponse<AgendaItem>>();

  const loadAgendaItems = useCallback(async () => {
    return loadData(
      'kn_cache_agenda_items',
      () => agendaService.getActiveAgendaItems(),
      { ttl: 5 * 60 * 1000 } // 5 minutes
    );
  }, [loadData]);

  const refreshAgendaItems = useCallback(async () => {
    return refresh(
      'kn_cache_agenda_items',
      () => agendaService.getActiveAgendaItems(),
      { ttl: 5 * 60 * 1000 }
    );
  }, [refresh]);

  const clearAgendaCache = useCallback(async () => {
    return clearCache('kn_cache_agenda_items');
  }, [clearCache]);

  return {
    agendaData: data,
    loading,
    error,
    loadAgendaItems,
    refreshAgendaItems,
    clearAgendaCache
  };
};

// Create: src/hooks/useAttendeeData.ts
export const useAttendeeData = () => {
  const { data, loading, error, loadData, refresh, clearCache } = useDataLoading<Attendee>();

  const loadAttendee = useCallback(async () => {
    return loadData(
      'kn_cache_attendee',
      () => getCurrentAttendeeData(),
      { ttl: 10 * 60 * 1000 } // 10 minutes
    );
  }, [loadData]);

  const refreshAttendee = useCallback(async () => {
    return refresh(
      'kn_cache_attendee',
      () => getCurrentAttendeeData(),
      { ttl: 10 * 60 * 1000 }
    );
  }, [refresh]);

  const clearAttendeeCache = useCallback(async () => {
    return clearCache('kn_cache_attendee');
  }, [clearCache]);

  return {
    attendeeData: data,
    loading,
    error,
    loadAttendee,
    refreshAttendee,
    clearAttendeeCache
  };
};
```

#### 3. Refactored Session Data Hook
```typescript
// Refactor: src/hooks/useSessionData.js
export const useSessionData = (options = {}) => {
  const { loadAgendaItems, agendaData, loading: agendaLoading, error: agendaError } = useAgendaData();
  const { loadAttendee, attendeeData, loading: attendeeLoading, error: attendeeError } = useAttendeeData();
  
  const [sessions, setSessions] = useState([]);
  const [allSessions, setAllSessions] = useState([]);
  const [currentSession, setCurrentSession] = useState(null);
  const [nextSession, setNextSession] = useState(null);
  const [seatAssignments, setSeatAssignments] = useState([]);

  const loadSessionData = useCallback(async () => {
    if (!isAuthenticated) {
      setSessions([]);
      setAllSessions([]);
      setCurrentSession(null);
      setNextSession(null);
      setSeatAssignments([]);
      return;
    }

    try {
      // Load agenda items
      const agendaResult = await loadAgendaItems();
      if (agendaResult?.success) {
        const allSessionsData = agendaResult.data || [];
        setAllSessions(allSessionsData);
        
        // Filter sessions for current attendee
        const filteredSessions = filterSessionsForAttendee(allSessionsData, attendeeData);
        setSessions(filteredSessions);
      }

      // Load attendee data
      await loadAttendee();

      // Load seat assignments
      if (attendeeData?.id) {
        try {
          const seatData = await getAttendeeSeatAssignments(attendeeData.id);
          setSeatAssignments(seatData);
        } catch (seatError) {
          console.warn('⚠️ Could not load seat assignments:', seatError);
          setSeatAssignments([]);
        }
      }
    } catch (error) {
      console.error('❌ Error loading session data:', error);
    }
  }, [isAuthenticated, loadAgendaItems, loadAttendee, attendeeData]);

  // ... rest of hook implementation
};
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] useDataLoading hook implemented and tested
- [ ] Specialized hooks created for common data types
- [ ] Existing hooks refactored to use new hook
- [ ] Error handling is consistent across all hooks
- [ ] Code review completed
- [ ] Documentation updated

## Testing Strategy

### Unit Tests
- Test useDataLoading hook with various scenarios
- Test specialized hooks functionality
- Test error handling and retry logic
- Test cache management

### Integration Tests
- Test integration with unified cache service
- Test hook composition and reusability
- Test error recovery patterns

### Manual Testing
- Test data loading across different components
- Test error handling and retry behavior
- Test cache behavior consistency

## Dependencies

- **Blocks:** Story 2.1f3 (UI State Management Hook)
- **Depends on:** Story 2.1f1 (Unified Cache Service)
- **Related:** Story 2.1c (Fix Cache Validation Logic)

## Notes

This story creates reusable data loading patterns that can be used across the application. It should be implemented after the unified cache service is in place.

## Acceptance Test Scenarios

1. **Reusability Test**: Hook can be used across different components
2. **Error Handling Test**: Error handling is consistent across all uses
3. **Cache Management Test**: Cache management is automatic and consistent
4. **Loading State Test**: Loading states are properly managed
5. **Retry Logic Test**: Retry logic works correctly with exponential backoff

## Hook Benefits

- **Reusability**: Single hook for all data loading needs
- **Consistency**: Uniform error handling and cache behavior
- **Maintainability**: Centralized data loading logic
- **Performance**: Optimized caching and retry strategies
- **Developer Experience**: Simple API for complex functionality
