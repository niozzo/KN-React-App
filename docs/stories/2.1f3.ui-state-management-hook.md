# Story 2.1f3: UI State Management Hook

**Epic:** Epic 2 - Core PWA Functionality  
**Story ID:** 2.1f3  
**Priority:** LOW  
**Story Points:** 3  
**Status:** Ready for Development  

## User Story

**As a** developer  
**I want** a reusable UI state management hook that handles state updates and validation  
**So that** I can manage UI state consistently across components

## Problem Statement

Currently, UI state management is mixed with data loading logic, making it difficult to manage state updates, validation, and error handling consistently across components.

## Acceptance Criteria

### Primary Criteria
- [ ] Reusable hook for UI state management
- [ ] Consistent state update patterns
- [ ] State validation capabilities
- [ ] Error state management

### Technical Criteria
- [ ] Create useUIState hook
- [ ] Add state validation functionality
- [ ] Implement error state management
- [ ] Add state persistence options

### Validation Criteria
- [ ] Hook can be used across different components
- [ ] State updates are consistent and predictable
- [ ] State validation works correctly
- [ ] Error states are properly managed

## Technical Implementation

### Files to Create/Modify
- `src/hooks/useUIState.ts` - New UI state management hook
- `src/hooks/useSessionData.js` - Refactor to use new hook
- `src/hooks/useFormState.ts` - Create form-specific hook
- `src/hooks/useToggleState.ts` - Create toggle-specific hook

### Code Changes Required

#### 1. Core UI State Hook
```typescript
// Create: src/hooks/useUIState.ts
export interface UIStateOptions<T> {
  initialValue?: T;
  validate?: (state: T) => boolean | string;
  persist?: boolean;
  storageKey?: string;
  debounceMs?: number;
}

export interface UIStateResult<T> {
  state: T;
  setState: (newState: T | ((prev: T) => T)) => void;
  updateState: (updates: Partial<T>) => void;
  resetState: () => void;
  validateState: () => boolean | string;
  isDirty: boolean;
  isValid: boolean;
  error: string | null;
  setError: (error: string | null) => void;
  clearError: () => void;
}

export const useUIState = <T>(
  initialState: T,
  options: UIStateOptions<T> = {}
): UIStateResult<T> => {
  const {
    validate,
    persist = false,
    storageKey,
    debounceMs = 300
  } = options;

  const [state, setState] = useState<T>(() => {
    if (persist && storageKey) {
      try {
        const stored = localStorage.getItem(storageKey);
        return stored ? JSON.parse(stored) : initialState;
      } catch {
        return initialState;
      }
    }
    return initialState;
  });

  const [isDirty, setIsDirty] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [validationResult, setValidationResult] = useState<boolean | string>(true);

  // Debounced validation
  const debouncedValidate = useMemo(
    () => debounce((currentState: T) => {
      if (validate) {
        const result = validate(currentState);
        setValidationResult(result);
        if (typeof result === 'string') {
          setError(result);
        } else if (result === false) {
          setError('Validation failed');
        } else {
          setError(null);
        }
      }
    }, debounceMs),
    [validate, debounceMs]
  );

  // Validate state when it changes
  useEffect(() => {
    debouncedValidate(state);
  }, [state, debouncedValidate]);

  // Persist state to localStorage
  useEffect(() => {
    if (persist && storageKey && isDirty) {
      try {
        localStorage.setItem(storageKey, JSON.stringify(state));
      } catch (error) {
        console.warn('Failed to persist state:', error);
      }
    }
  }, [state, persist, storageKey, isDirty]);

  const updateState = useCallback((updates: Partial<T>) => {
    setState(prev => ({ ...prev, ...updates }));
    setIsDirty(true);
  }, []);

  const resetState = useCallback(() => {
    setState(initialState);
    setIsDirty(false);
    setError(null);
    setValidationResult(true);
  }, [initialState]);

  const validateState = useCallback(() => {
    if (validate) {
      const result = validate(state);
      setValidationResult(result);
      return result;
    }
    return true;
  }, [state, validate]);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  const isValid = validationResult === true;

  return {
    state,
    setState,
    updateState,
    resetState,
    validateState,
    isDirty,
    isValid,
    error,
    setError,
    clearError
  };
};
```

#### 2. Specialized State Hooks
```typescript
// Create: src/hooks/useFormState.ts
export interface FormState<T> {
  values: T;
  errors: Partial<Record<keyof T, string>>;
  touched: Partial<Record<keyof T, boolean>>;
  isSubmitting: boolean;
  isValid: boolean;
  isDirty: boolean;
}

export const useFormState = <T extends Record<string, any>>(
  initialValues: T,
  validationSchema?: Record<keyof T, (value: any) => string | null>
) => {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({});
  const [touched, setTouched] = useState<Partial<Record<keyof T, boolean>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const setValue = useCallback((field: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [field]: value }));
    setTouched(prev => ({ ...prev, [field]: true }));
    
    // Validate field
    if (validationSchema?.[field]) {
      const error = validationSchema[field](value);
      setErrors(prev => ({ ...prev, [field]: error || undefined }));
    }
  }, [validationSchema]);

  const setValues = useCallback((newValues: Partial<T>) => {
    setValues(prev => ({ ...prev, ...newValues }));
    setTouched(prev => ({ ...prev, ...Object.keys(newValues).reduce((acc, key) => ({ ...acc, [key]: true }), {}) }));
  }, []);

  const validateField = useCallback((field: keyof T) => {
    if (validationSchema?.[field]) {
      const error = validationSchema[field](values[field]);
      setErrors(prev => ({ ...prev, [field]: error || undefined }));
      return !error;
    }
    return true;
  }, [values, validationSchema]);

  const validateForm = useCallback(() => {
    if (!validationSchema) return true;
    
    const newErrors: Partial<Record<keyof T, string>> = {};
    let isValid = true;

    Object.keys(validationSchema).forEach(field => {
      const error = validationSchema[field as keyof T](values[field as keyof T]);
      if (error) {
        newErrors[field as keyof T] = error;
        isValid = false;
      }
    });

    setErrors(newErrors);
    return isValid;
  }, [values, validationSchema]);

  const resetForm = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  const isDirty = useMemo(() => {
    return Object.keys(values).some(key => 
      values[key as keyof T] !== initialValues[key as keyof T]
    );
  }, [values, initialValues]);

  const isValid = useMemo(() => {
    return Object.values(errors).every(error => !error);
  }, [errors]);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    isValid,
    isDirty,
    setValue,
    setValues,
    validateField,
    validateForm,
    resetForm,
    setIsSubmitting
  };
};

// Create: src/hooks/useToggleState.ts
export const useToggleState = (
  initialValue: boolean = false,
  options: {
    persist?: boolean;
    storageKey?: string;
    onToggle?: (value: boolean) => void;
  } = {}
) => {
  const { persist = false, storageKey, onToggle } = options;

  const [state, setState] = useState<boolean>(() => {
    if (persist && storageKey) {
      try {
        const stored = localStorage.getItem(storageKey);
        return stored ? JSON.parse(stored) : initialValue;
      } catch {
        return initialValue;
      }
    }
    return initialValue;
  });

  const toggle = useCallback(() => {
    setState(prev => {
      const newValue = !prev;
      onToggle?.(newValue);
      return newValue;
    });
  }, [onToggle]);

  const setValue = useCallback((value: boolean) => {
    setState(value);
    onToggle?.(value);
  }, [onToggle]);

  // Persist to localStorage
  useEffect(() => {
    if (persist && storageKey) {
      try {
        localStorage.setItem(storageKey, JSON.stringify(state));
      } catch (error) {
        console.warn('Failed to persist toggle state:', error);
      }
    }
  }, [state, persist, storageKey]);

  return {
    value: state,
    toggle,
    setValue,
    isOn: state,
    isOff: !state
  };
};
```

#### 3. Refactored Session Data Hook
```typescript
// Refactor: src/hooks/useSessionData.js
export const useSessionData = (options = {}) => {
  const { loadAgendaItems, agendaData, loading: agendaLoading, error: agendaError } = useAgendaData();
  const { loadAttendee, attendeeData, loading: attendeeLoading, error: attendeeError } = useAttendeeData();
  
  // Use UI state hook for session management
  const sessionState = useUIState({
    sessions: [],
    allSessions: [],
    currentSession: null,
    nextSession: null,
    seatAssignments: []
  }, {
    validate: (state) => {
      if (state.sessions.length === 0 && state.allSessions.length > 0) {
        return 'Sessions filtered but no results';
      }
      return true;
    }
  });

  const loadSessionData = useCallback(async () => {
    if (!isAuthenticated) {
      sessionState.resetState();
      return;
    }

    try {
      // Load agenda items
      const agendaResult = await loadAgendaItems();
      if (agendaResult?.success) {
        const allSessionsData = agendaResult.data || [];
        sessionState.updateState({ allSessions: allSessionsData });
        
        // Filter sessions for current attendee
        const filteredSessions = filterSessionsForAttendee(allSessionsData, attendeeData);
        sessionState.updateState({ sessions: filteredSessions });
      }

      // Load attendee data
      await loadAttendee();

      // Load seat assignments
      if (attendeeData?.id) {
        try {
          const seatData = await getAttendeeSeatAssignments(attendeeData.id);
          sessionState.updateState({ seatAssignments: seatData });
        } catch (seatError) {
          console.warn('⚠️ Could not load seat assignments:', seatError);
          sessionState.updateState({ seatAssignments: [] });
        }
      }
    } catch (error) {
      console.error('❌ Error loading session data:', error);
      sessionState.setError(error.message);
    }
  }, [isAuthenticated, loadAgendaItems, loadAttendee, attendeeData, sessionState]);

  // ... rest of hook implementation
};
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] useUIState hook implemented and tested
- [ ] Specialized state hooks created
- [ ] Existing hooks refactored to use new hooks
- [ ] State validation works correctly
- [ ] Error state management is consistent
- [ ] Code review completed
- [ ] Documentation updated

## Testing Strategy

### Unit Tests
- Test useUIState hook with various scenarios
- Test specialized state hooks functionality
- Test state validation and error handling
- Test persistence functionality

### Integration Tests
- Test hook composition and reusability
- Test state management across components
- Test validation integration

### Manual Testing
- Test state management across different components
- Test validation and error handling
- Test persistence behavior

## Dependencies

- **Blocks:** Story 2.1f4 (Integration & Testing)
- **Depends on:** Story 2.1f2 (Data Loading Hook)
- **Related:** Story 2.1c (Fix Cache Validation Logic)

## Notes

This story creates reusable UI state management patterns that can be used across the application. It should be implemented after the data loading hook is in place.

## Acceptance Test Scenarios

1. **Reusability Test**: Hook can be used across different components
2. **State Update Test**: State updates are consistent and predictable
3. **Validation Test**: State validation works correctly
4. **Error State Test**: Error states are properly managed
5. **Persistence Test**: State persistence works correctly

## Hook Benefits

- **Reusability**: Single hook for all UI state management needs
- **Consistency**: Uniform state update and validation patterns
- **Maintainability**: Centralized state management logic
- **Performance**: Optimized state updates and validation
- **Developer Experience**: Simple API for complex state management
