# Story 2.1f4: Integration & Testing

**Epic:** Epic 2 - Core PWA Functionality  
**Story ID:** 2.1f4  
**Priority:** LOW  
**Story Points:** 2  
**Status:** Ready for Development  

## User Story

**As a** developer  
**I want** comprehensive integration testing for the new state management architecture  
**So that** I can ensure all components work together correctly and prevent regressions

## Problem Statement

With the new unified cache service, data loading hooks, and UI state management hooks, we need comprehensive integration testing to ensure all components work together correctly and don't introduce regressions.

## Acceptance Criteria

### Primary Criteria
- [ ] Integration tests cover all new components working together
- [ ] End-to-end testing validates complete data flow
- [ ] Performance testing ensures no degradation
- [ ] Regression testing prevents breaking changes

### Technical Criteria
- [ ] Create integration test suite
- [ ] Add end-to-end test scenarios
- [ ] Implement performance benchmarks
- [ ] Add regression test coverage

### Validation Criteria
- [ ] All integration tests pass
- [ ] End-to-end scenarios work correctly
- [ ] Performance meets benchmarks
- [ ] No regressions in existing functionality

## Technical Implementation

### Files to Create/Modify
- `src/__tests__/integration/state-management-integration.test.ts` - Integration tests
- `src/__tests__/e2e/cache-flow.test.ts` - End-to-end tests
- `src/__tests__/performance/cache-performance.test.ts` - Performance tests
- `src/__tests__/regression/state-management-regression.test.ts` - Regression tests

### Code Changes Required

#### 1. Integration Test Suite
```typescript
// Create: src/__tests__/integration/state-management-integration.test.ts
import { renderHook, act } from '@testing-library/react';
import { useDataLoading } from '../../hooks/useDataLoading';
import { useUIState } from '../../hooks/useUIState';
import { useAgendaData } from '../../hooks/useAgendaData';
import { UnifiedCacheService } from '../../services/unifiedCacheService';

describe('State Management Integration', () => {
  let mockUnifiedCache: jest.Mocked<UnifiedCacheService>;
  let mockAgendaService: jest.Mocked<any>;

  beforeEach(() => {
    mockUnifiedCache = {
      get: jest.fn(),
      set: jest.fn(),
      remove: jest.fn(),
      invalidate: jest.fn(),
      clear: jest.fn(),
      getHealthStatus: jest.fn()
    } as any;

    mockAgendaService = {
      getActiveAgendaItems: jest.fn()
    };

    // Mock service dependencies
    jest.doMock('../../services/unifiedCacheService', () => ({
      UnifiedCacheService: jest.fn(() => mockUnifiedCache)
    }));

    jest.doMock('../../services/agendaService', () => ({
      agendaService: mockAgendaService
    }));
  });

  describe('Data Loading + UI State Integration', () => {
    it('should load data and update UI state correctly', async () => {
      const mockData = { data: [{ id: '1', title: 'Test Session' }], success: true };
      mockAgendaService.getActiveAgendaItems.mockResolvedValue(mockData);
      mockUnifiedCache.get.mockResolvedValue(null);

      const { result } = renderHook(() => useAgendaData());

      await act(async () => {
        await result.current.loadAgendaItems();
      });

      expect(result.current.agendaData).toEqual(mockData);
      expect(result.current.loading).toBe(false);
      expect(result.current.error).toBeNull();
    });

    it('should handle cache hits correctly', async () => {
      const mockData = { data: [{ id: '1', title: 'Test Session' }], success: true };
      mockUnifiedCache.get.mockResolvedValue(mockData);

      const { result } = renderHook(() => useAgendaData());

      await act(async () => {
        await result.current.loadAgendaItems();
      });

      expect(mockUnifiedCache.get).toHaveBeenCalledWith('kn_cache_agenda_items');
      expect(result.current.agendaData).toEqual(mockData);
      expect(mockAgendaService.getActiveAgendaItems).not.toHaveBeenCalled();
    });

    it('should handle errors gracefully', async () => {
      const error = new Error('Network error');
      mockAgendaService.getActiveAgendaItems.mockRejectedValue(error);
      mockUnifiedCache.get.mockResolvedValue(null);

      const { result } = renderHook(() => useAgendaData());

      await act(async () => {
        await result.current.loadAgendaItems();
      });

      expect(result.current.error).toBe('Network error');
      expect(result.current.agendaData).toBeNull();
    });
  });

  describe('Cache Service Integration', () => {
    it('should integrate with unified cache service', async () => {
      const { result } = renderHook(() => useDataLoading());

      await act(async () => {
        await result.current.loadData('test-key', () => Promise.resolve('test-data'));
      });

      expect(mockUnifiedCache.set).toHaveBeenCalledWith('test-key', 'test-data', expect.any(Number));
    });

    it('should handle cache invalidation', async () => {
      const { result } = renderHook(() => useDataLoading());

      await act(async () => {
        await result.current.clearCache('test-key');
      });

      expect(mockUnifiedCache.remove).toHaveBeenCalledWith('test-key');
    });
  });

  describe('UI State Validation', () => {
    it('should validate state correctly', () => {
      const { result } = renderHook(() => useUIState(
        { sessions: [], allSessions: [] },
        {
          validate: (state) => {
            if (state.sessions.length === 0 && state.allSessions.length > 0) {
              return 'Sessions filtered but no results';
            }
            return true;
          }
        }
      ));

      act(() => {
        result.current.updateState({ allSessions: [{ id: '1', title: 'Test' }] });
      });

      expect(result.current.isValid).toBe(false);
      expect(result.current.error).toBe('Sessions filtered but no results');
    });
  });
});
```

#### 2. End-to-End Test Suite
```typescript
// Create: src/__tests__/e2e/cache-flow.test.ts
import { render, screen, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { HomePage } from '../../pages/HomePage';
import { AuthProvider } from '../../contexts/AuthContext';

describe('Cache Flow End-to-End', () => {
  beforeEach(() => {
    // Mock localStorage
    const mockLocalStorage = {
      getItem: jest.fn(),
      setItem: jest.fn(),
      removeItem: jest.fn(),
      clear: jest.fn()
    };
    Object.defineProperty(window, 'localStorage', { value: mockLocalStorage });

    // Mock authentication
    jest.doMock('../../contexts/AuthContext', () => ({
      useAuth: () => ({ isAuthenticated: true, attendee: { id: 'test-user' } })
    }));
  });

  it('should complete full data loading flow', async () => {
    const mockAgendaData = {
      data: [
        { id: '1', title: 'Morning Session', isActive: true },
        { id: '2', title: 'Afternoon Session', isActive: true }
      ],
      success: true
    };

    // Mock API responses
    global.fetch = jest.fn()
      .mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockAgendaData.data)
      })
      .mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({ id: 'test-user', name: 'Test User' })
      });

    render(
      <BrowserRouter>
        <AuthProvider>
          <HomePage />
        </AuthProvider>
      </BrowserRouter>
    );

    // Wait for data to load
    await waitFor(() => {
      expect(screen.getByText('Morning Session')).toBeInTheDocument();
    });

    expect(screen.getByText('Afternoon Session')).toBeInTheDocument();
  });

  it('should handle cache corruption gracefully', async () => {
    // Mock corrupted cache
    const mockLocalStorage = {
      getItem: jest.fn((key) => {
        if (key === 'kn_cache_agenda_items') {
          return '{"data": [{"id": "1", "title": "Test"}], "version": "1.0.0", "timestamp": "2025-01-01T00:00:00Z"}';
        }
        return null;
      }),
      setItem: jest.fn(),
      removeItem: jest.fn(),
      clear: jest.fn()
    };
    Object.defineProperty(window, 'localStorage', { value: mockLocalStorage });

    render(
      <BrowserRouter>
        <AuthProvider>
          <HomePage />
        </AuthProvider>
      </BrowserRouter>
    );

    // Should handle corrupted cache and fallback to server
    await waitFor(() => {
      expect(screen.getByText('Loading your schedule...')).toBeInTheDocument();
    });
  });
});
```

#### 3. Performance Test Suite
```typescript
// Create: src/__tests__/performance/cache-performance.test.ts
import { performance } from 'perf_hooks';
import { UnifiedCacheService } from '../../services/unifiedCacheService';

describe('Cache Performance', () => {
  let cacheService: UnifiedCacheService;
  const largeDataset = Array.from({ length: 1000 }, (_, i) => ({
    id: `item-${i}`,
    title: `Session ${i}`,
    data: `Large data payload ${i}`.repeat(100)
  }));

  beforeEach(() => {
    cacheService = new UnifiedCacheService();
  });

  it('should handle large datasets efficiently', async () => {
    const startTime = performance.now();

    await cacheService.set('large-dataset', largeDataset);

    const endTime = performance.now();
    const duration = endTime - startTime;

    expect(duration).toBeLessThan(100); // Should complete in under 100ms
  });

  it('should retrieve large datasets efficiently', async () => {
    await cacheService.set('large-dataset', largeDataset);

    const startTime = performance.now();
    const retrieved = await cacheService.get('large-dataset');
    const endTime = performance.now();
    const duration = endTime - startTime;

    expect(retrieved).toEqual(largeDataset);
    expect(duration).toBeLessThan(50); // Should retrieve in under 50ms
  });

  it('should handle concurrent operations', async () => {
    const operations = Array.from({ length: 100 }, (_, i) => 
      cacheService.set(`key-${i}`, { data: `value-${i}` })
    );

    const startTime = performance.now();
    await Promise.all(operations);
    const endTime = performance.now();
    const duration = endTime - startTime;

    expect(duration).toBeLessThan(500); // Should complete all operations in under 500ms
  });

  it('should maintain memory efficiency', async () => {
    const initialMemory = process.memoryUsage().heapUsed;

    // Perform many cache operations
    for (let i = 0; i < 1000; i++) {
      await cacheService.set(`key-${i}`, { data: `value-${i}` });
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = finalMemory - initialMemory;

    expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // Should not increase by more than 50MB
  });
});
```

#### 4. Regression Test Suite
```typescript
// Create: src/__tests__/regression/state-management-regression.test.ts
import { renderHook, act } from '@testing-library/react';
import { useSessionData } from '../../hooks/useSessionData';

describe('State Management Regression Tests', () => {
  it('should not break existing session data functionality', async () => {
    const { result } = renderHook(() => useSessionData());

    // Test that existing functionality still works
    expect(result.current.sessions).toEqual([]);
    expect(result.current.currentSession).toBeNull();
    expect(result.current.nextSession).toBeNull();
    expect(result.current.isLoading).toBe(false);
  });

  it('should maintain backward compatibility with existing cache keys', async () => {
    // Test that existing cache keys still work
    const existingCacheData = {
      data: [{ id: '1', title: 'Existing Session' }],
      timestamp: new Date().toISOString(),
      version: '1.0.0'
    };

    localStorage.setItem('kn_cache_agenda_items', JSON.stringify(existingCacheData));

    const { result } = renderHook(() => useSessionData());

    await act(async () => {
      await result.current.loadSessionData();
    });

    // Should handle existing cache format
    expect(result.current.sessions).toBeDefined();
  });

  it('should not introduce memory leaks', async () => {
    const { result, unmount } = renderHook(() => useSessionData());

    // Perform operations
    await act(async () => {
      await result.current.loadSessionData();
    });

    // Unmount and check for cleanup
    unmount();

    // Should not have any lingering references
    expect(result.current).toBeDefined();
  });
});
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Integration test suite created and passing
- [ ] End-to-end test scenarios implemented
- [ ] Performance benchmarks established and met
- [ ] Regression tests prevent breaking changes
- [ ] Test coverage is >90% for new components
- [ ] Code review completed
- [ ] Documentation updated

## Testing Strategy

### Integration Tests
- Test all new components working together
- Test data flow from cache to UI
- Test error handling across components
- Test state synchronization

### End-to-End Tests
- Test complete user workflows
- Test cache corruption scenarios
- Test network failure recovery
- Test data persistence

### Performance Tests
- Test with large datasets
- Test concurrent operations
- Test memory usage
- Test response times

### Regression Tests
- Test backward compatibility
- Test existing functionality
- Test memory leak prevention
- Test breaking change prevention

## Dependencies

- **Blocks:** None
- **Depends on:** Story 2.1f3 (UI State Management Hook)
- **Related:** All previous stories in the sequence

## Notes

This story ensures the new state management architecture is thoroughly tested and doesn't introduce regressions. It should be implemented after all the other stories in the sequence.

## Acceptance Test Scenarios

1. **Integration Test**: All components work together correctly
2. **End-to-End Test**: Complete data flow works from cache to UI
3. **Performance Test**: Performance meets established benchmarks
4. **Regression Test**: No existing functionality is broken
5. **Coverage Test**: Test coverage is >90% for new components

## Test Coverage Requirements

- **Unit Tests**: >95% coverage for new hooks and services
- **Integration Tests**: >90% coverage for component interactions
- **End-to-End Tests**: >80% coverage for user workflows
- **Performance Tests**: All performance benchmarks met
- **Regression Tests**: 100% backward compatibility maintained
